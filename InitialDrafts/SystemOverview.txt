Abstract


In recent years, quad-rotor UAV (Unmanned Aerial Vehicle) technology has taken off in the research and commercial realm, and allowed for new possibilities in ISR (Imaging, Recovery and Surveillance) with civilian and military applications. Development of robust inner and outer-loop control strategies on these platforms has thus been an important research topic. Additionally, development of hardware solutions that efficiently package the increasing variety of computational platforms in a space, weight and power-saving manner has been paramount in order to ensure longer flight times and achieve more complex missions. The scope of this project has thus been to develop mechanical and electronic hardware and firmware improvements in order to create a quadcopter optimized for image-processing tasks. A dual-brain control architecture has been developed in order to segment the "inner-loop" hard-realtime tasks involving vehicle guidance, navigation and control (GNC), and "outer-loop" control involving mission planning, debugging, image processing and vision-driven navigation decision generation and trajectory generation.

Hardware overview:

A quad-rotor UAV is an under-actuated robotic platform that consists of 4 propellers driven independently, with each motor being mechanically coupled in the rotational axis to a BLDC (Brushless DC) motor. The motors are 3-phase motors and have a very high power-to-weight ratio and energy efficiency; these properties are ideal on an airborne platform where one is optimizing the flight time (i.e. endurance) and payload capacity. The control of these motors is performed by hardware known as an ESC (Electronic Speed Controller) which is used commonly by R/C (radio control) hobbyists as well. The ESC takes motor speed (RPM) commands from the flight computer and converts them accordingly into power outputs on 3 phases which then drive the windings of the BLDC motor. In the case of the ESCs on this vehicle, the ESC accepts PWM commands from the flight control system, where the desired RPM is expressed as the PWM duty cycle. A variety of industry and academic research has gone into BLDC control, and means that high-quality ESCs are available off-the-shelf that meet the control bandwidth requirements for a quad-rotor platform. Because of this, several ESCs were tried before the decision was made to use Hobbyking's "Afro/SimonK" series of ESCs with firmware tuned specifically for multirotor applications. These ESCs also sport substantially higher update rates, allowing for faster control and improvements in control system performance.

The next major piece of hardware that must be considered is the flight computer (or possibly in the plural). In the case of the quadcopter developed here, a multi-brain flight computer architecture has been developed to address the research objectives (namely, image processing, high-level path-planning and ease of debug and telemetry forwarding.) In keeping with these goals, the vehicle actually has two flight computers that shall be referred to as the PFC and SFC (Primary and Secondary Flight Computers respectively.) The PFC has the role of performing "hard" real-time sensor data acquisition, command processing, state estimation and inner-loop stabilization of the vehicle. It consists of a set of real-time microcontrollers connected to a variety of sensors on a PCB. The sensors include IMU (inertial Measurement Unit), pressure sensor (for altitude/airspeed sensing), ADC (Analog-Digital converters), DAC (Digital-Analog Converters), etc. In addition to the sensor package included on the PFC's circuit board, it also interfaces to other sensors through a set of wiring harnesses. These include a ToF (Time-Of-Flight) LIDAR (Light-ranging sensor) altimeter, auxiliary IMU/heading sensor and a Px4Flow Optical Flow sensor that provides an estimate of lateral velocity over the ground. In general, this means that task intervals on the flight software on the PFC can range from hundreds of micro-seconds to a few milliseconds, with maximum allowable and observed latency bounds on the order of tens of microseconds. Additionally, the PFC directly receives user flight commands through an analog PWM (pulse-width mudulation) interface for human-in-the-loop flight modes where the user can directly command vehicle movement characteristics such as velocity, attitude or attitude rate, and also can switch to a completely fail-safe mode that eliminates software considered to be potentially unstable, and instead run software that is "known good" and has substantial confidence testing and flight heritage. Additionally, in this mode no inputs are accepted from the communication interface to the SFC, thus eliminating any potential for propagation of SFC software/hardware faults into the PFC's ability to control the vehicle in a safe manner.

The SFC is a commercially-available off-the-shelf Linux single board computer (SBC) and serves several purposes. As a system running Linux, it provides a variety of open-source debugging and software development capabilities that would be difficult if not impossible to implement on the PFC, given its "bare-metal" nature. Even if a real-time operating system is utilized on the PFC, the limited resources make it difficult to implement a lot of the facilities available readily within a Linux enviornment. The SFC is a very powerful hardware platform, and in the case of this vehicle is an Odroid XU4 board. It contains a Samsung Exynos SoC (System-on-chip) with an ARM Cortex-A15 and A7 hybrid core running at up to 2 GHz. It has 2 GB RAM, USB, Gigabit Ethernet and HDMI, allowing for a large variety of interface options and peripheral attachment. It also provides an ideal platform to perform computer vision tasks, due to the processing power and USB interface which makes it possible to connect any off-the-shelf webcam. Additionally, the availability of USB and Ethernet means that various network interfaces ranging from switches to WiFi and 4G modules can be employed to provide almost unlimited-range debugging, telemetry and command and control tasks. In conjunction with a ground station application running on a user PC/laptop, it is possible to view real-time data streams, uplink commands and movement waypoints, and view video streams. The entire data stream from the vehicle is also downlinked and recorded, allowing for post-flight analysis and fault identification in the event of an anomaly, even if the on-board avionics are severely damaged or otherwise unavailable.

Software overview:

Developing the software necessary for successful and safe command and control of a UAV demands a structured approach to software development and segmentation of tasks between the PFC and SFC. Additionally, the HMI (Human-machine interaction) aspect must be considered when deciding how exactly the ground station application will fit into the operational aspects of the UAV.

As mentioned in the hardware overview, the primary task of the PFC is to run real-time inner-loop control algorithms that use inputs from sensors on the UAV to generate the 4 ESC actuator commands and stabilize the vehicle. To simplify development and improve efficiency, the firmware is written in the C programming language and the use of an operating system is omitted to reduce unnecessary overhead and code size. Instead, a "meta-operating system" is designed, in a sense, to provide some familiar operating system-like structures and development conventions while skipping some overhead that would normally be acceptable on a desktop but not on a deeply-embedded environment. As a reference, the POSIX system API (Application Programming Interface) was considered and used as a baseline in the development of much of the high-level system software running on the PFC. The POSIX API originated in early versions of the UNIX operating system, and has been worked on and with by numerous programmers to this day, culminating in its present-day use in the open-source Linux operating system and contemporary flavors of UNIX and other UNIX-like systems. It is also used in the Macintosh and Windows operating systems quite frequently.

Adherence to the POSIX API (or to similar conventions) reduces developmental overhead and eases portability of flight software between C test harnesses written and run in simulation enviornments on Linux workstations, and the PFC. Quite often, it becomes possible to test, debug and validate a module on a Linux workstation where various debug utilities are available (such as the standard terminal I/O), and with almost no major software modifications port the application/module to the PFC's flight software codebase where it can run in real-time. Additionally, a 3-tiered system of abstraction allows the flight software to be ported rapidly between various hardware platforms rapidly, while preserving behavior of the software and the low-level firmware modules.

A major challenge in the development of the PFC's flight software involves the ability of a user to debug and perform introspection into various critical parameters of the inner-loop control system. For example, it might be quite useful to be able to view sensor data and parameters in real-time, or inject a set of such values from the ground while the vehicle is airbourne to assist in characterization. It might be necessary to change control system gain parameters to improve stability while flying the UAV. It is also useful to have a core set of software tools with which to rapidly view and manipulate incoming data streams in realtime or post-flight, for better analysis of vehicle behavior. Thus, development of telemetry software is a critical step in being able to optimally operate the UAV and use it to its full potential as a research platform. It is here that the presence of the SFC becomes very important and useful. Traditionally, most UAVs with only one embedded flight computer rely on some kind of low-bitrate communications mechanism such as an IEEE 802.15.4 (commonly known by the ZigBee designation) module or other radio that acts as a transparent "bridge" for serial UART communications. A downside of such a system is its inherent bandwidth and range limitation (most of these modules only provide up to a mile of line-of-sight range, with price and power consumption rapidly increasing for modules with better range.) Most 802.15.4 modules realistically provide up to a few hundred Kbps of bandwidth in either direction, and quite often are half-duplex, which leads to major difficulty in implementing a real-time 2-way communications scheme. Also, streaming video over such a link is highly un-realistic. 

Based on these considerations, it was chosen to leverage the SFC in this project as a communications relay/proxy. A simple communications packet protocol (TRTP, or Trivial Robot Transfer Protocol) was developed that would be used in a wired serial UART communications link between the PFC and SFC. The two are connected together using an FTDI USB-Serial UART conversion IC. The wired serial UART allows for fairly high bandwidth (presently 460 Kbps, though rates up to 2 Mbps are possible) with full-duplex capability. Data encoded in TRTP consists of a "tag" or identifier string, a timestamp, and binary-encoded payload that can be either a set of N floating-point or integer numbers. Data in this format is sent from the PFC to the SFC over the wired link, where a small Python "proxy" application encapsulates each TRTP packet inside a UDP packet after performing a checksum verification step. The packets are then sent to an IP multicast group, which permits for efficient use of network bandwidth by allowing routers to be configured to forward individual telemetry packets to any endpoint that is "subscribed" to the stream. Of course, this use of multicasting is optimized for Ethernet and WiFi network where it is possible to configure IP Multicast forwarding rules. In the event that the network interface being used by the SFC is incapable of this, it is possible to change the proxy application to use unicast, or to configure a multicast "tunnel" to some endpoint where multicast is configured. This makes possible long-range backhaul operations where data can be sent from the UAV via satellite/4G links to a base station, where it can be re-converted to multicast and distributed to multiple recipients through the use of multicast subscriptions. In any event, UDP-encapsulated TRTP packets arrive at all configured endpoints on a IP network, where a client Python application can "see" or "peek at" all of the data stream in the multicast stream. The Python client application can then utilize a user-supplied "filter" to only show messages matching a specific string descriptor. Additionally, the raw telemetry stream can be easily logged using common network traffic analysis tools such as Wireshark, and analyzed post-flight.

