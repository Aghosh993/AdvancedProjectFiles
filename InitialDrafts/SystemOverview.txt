Abstract


In recent years, quad-rotor UAV (Unmanned Aerial Vehicle) technology has taken off in the research and commercial realm, and allowed for new possibilities in ISR (Imaging, Recovery and Surveillance) with civilian and military applications. Development of robust inner and outer-loop control strategies on these platforms has thus been an important research topic. Additionally, development of hardware solutions that efficiently package the increasing variety of computational platforms in a space, weight and power-saving manner has been paramount in order to ensure longer flight times and achieve more complex missions. The scope of this project has thus been to develop mechanical and electronic hardware and firmware improvements in order to create a quadcopter optimized for image-processing tasks. A dual-brain control architecture has been developed in order to segment the "inner-loop" hard-realtime tasks involving vehicle guidance, navigation and control (GNC), and "outer-loop" control involving mission planning, debugging, image processing and vision-driven navigation decision generation and trajectory generation.

Hardware overview:

A quad-rotor UAV is an under-actuated robotic platform that consists of 4 propellers driven independently, with each motor being mechanically coupled in the rotational axis to a BLDC (Brushless DC) motor. The motors are 3-phase motors and have a very high power-to-weight ratio and energy efficiency; these properties are ideal on an airborne platform where one is optimizing the flight time (i.e. endurance) and payload capacity. The control of these motors is performed by hardware known as an ESC (Electronic Speed Controller) which is used commonly by R/C (radio control) hobbyists as well. The ESC takes motor speed (RPM) commands from the flight computer and converts them accordingly into power outputs on 3 phases which then drive the windings of the BLDC motor. In the case of the ESCs on this vehicle, the ESC accepts PWM commands from the flight control system, where the desired RPM is expressed as the PWM duty cycle. A variety of industry and academic research has gone into BLDC control, and means that high-quality ESCs are available off-the-shelf that meet the control bandwidth requirements for a quad-rotor platform. Because of this, several ESCs were tried before the decision was made to use Hobbyking's "Afro/SimonK" series of ESCs with firmware tuned specifically for multirotor applications. These ESCs also sport substantially higher update rates, allowing for faster control and improvements in control system performance.

The next major piece of hardware that must be considered is the flight computer (or possibly in the plural). In the case of the quadcopter developed here, a multi-brain flight computer architecture has been developed to address the research objectives (namely, image processing, high-level path-planning and ease of debug and telemetry forwarding.) In keeping with these goals, the vehicle actually has two flight computers that shall be referred to as the PFC and SFC (Primary and Secondary Flight Computers respectively.) The PFC has the role of performing "hard" real-time sensor data acquisition, command processing, state estimation and inner-loop stabilization of the vehicle. It consists of a set of real-time microcontrollers connected to a variety of sensors on a PCB. The sensors include IMU (inertial Measurement Unit), pressure sensor (for altitude/airspeed sensing), ADC (Analog-Digital converters), DAC (Digital-Analog Converters), etc. In addition to the sensor package included on the PFC's circuit board, it also interfaces to other sensors through a set of wiring harnesses. These include a ToF (Time-Of-Flight) LIDAR (Light-ranging sensor) altimeter, auxiliary IMU/heading sensor and a Px4Flow Optical Flow sensor that provides an estimate of lateral velocity over the ground. In general, this means that task intervals on the flight software on the PFC can range from hundreds of micro-seconds to a few milliseconds, with maximum allowable and observed latency bounds on the order of tens of microseconds. Additionally, the PFC directly receives user flight commands through an analog PWM (pulse-width mudulation) interface for human-in-the-loop flight modes where the user can directly command vehicle movement characteristics such as velocity, attitude or attitude rate, and also can switch to a completely fail-safe mode that eliminates software considered to be potentially unstable, and instead run software that is "known good" and has substantial confidence testing and flight heritage. Additionally, in this mode no inputs are accepted from the communication interface to the SFC, thus eliminating any potential for propagation of SFC software/hardware faults into the PFC's ability to control the vehicle in a safe manner.

The SFC is a commercially-available off-the-shelf Linux single board computer (SBC) and serves several purposes. As a system running Linux, it provides a variety of open-source debugging and software development capabilities that would be difficult if not impossible to implement on the PFC, given its "bare-metal" nature. Even if a real-time operating system is utilized on the PFC, the limited resources make it difficult to implement a lot of the facilities available readily within a Linux enviornment. The SFC is a very powerful hardware platform, and in the case of this vehicle is an Odroid XU4 board. It contains a Samsung Exynos SoC (System-on-chip) with an ARM Cortex-A15 and A7 hybrid core running at up to 2 GHz. It has 2 GB RAM, USB, Gigabit Ethernet and HDMI, allowing for a large variety of interface options and peripheral attachment. It also provides an ideal platform to perform computer vision tasks, due to the processing power and USB interface which makes it possible to connect any off-the-shelf webcam. Additionally, the availability of USB and Ethernet means that various network interfaces ranging from switches to WiFi and 4G modules can be employed to provide almost unlimited-range debugging, telemetry and command and control tasks. In conjunction with a ground station application running on a user PC/laptop, it is possible to view real-time data streams, uplink commands and movement waypoints, and view video streams. The entire data stream from the vehicle is also downlinked and recorded, allowing for post-flight analysis and fault identification in the event of an anomaly, even if the on-board avionics are severely damaged or otherwise unavailable.

Software architecture:

Developing the software necessary for successful and safe command and control of a UAV demands a structured approach to software development and segmentation of tasks between the PFC and SFC. Additionally, the HMI (Human-machine interaction) aspect must be considered when deciding how exactly the ground station application will fit into the operational aspects of the UAV.

As mentioned in the hardware overview, the primary task of the PFC is to run real-time inner-loop control algorithms that use inputs from sensors on the UAV to generate the 4 ESC actuator commands and stabilize the vehicle. To simplify development and improve efficiency, the firmware is written in the C programming language and the use of an operating system is omitted to reduce unnecessary overhead and code size. Instead, a "meta-operating system" is designed, in a sense, to provide some familiar operating system-like structures and development conventions while skipping some overhead that would normally be acceptable on a desktop but not on a deeply-embedded environment. As a reference, the POSIX system API (Application Programming Interface) was considered and used as a baseline in the development of much of the high-level system software running on the PFC. The POSIX API originated in early versions of the UNIX operating system, and has been worked on and with by numerous programmers to this day, culminating in its present-day use in the open-source Linux operating system and contemporary flavors of UNIX and other UNIX-like systems. It is also used in the Macintosh and Windows operating systems quite frequently.

Adherence to the POSIX API (or to similar conventions) reduces developmental overhead and eases portability of flight software between C test harnesses written and run in simulation enviornments on Linux workstations, and the PFC. Quite often, it becomes possible to test, debug and validate a module on a Linux workstation where various debug utilities are available (such as the standard terminal I/O), and with almost no major software modifications port the application/module to the PFC's flight software codebase where it can run in real-time.